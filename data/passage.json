{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1654479920002281473",
        "title": "整合SpringSecurity自定义登录流程",
        "description": null,
        "content": "### 前言\n\n自定义登录流程是整合 SpringSecurity 开发必不可少的一步。[上篇文章](https://juejin.cn/post/7227020874888331324)我们介绍了整合数据库的登录，本篇文章在此基础上整理了 SpringSecurity + JWT + Redis 的登录流程。\n\n### 整体流程图\n\n登录及认证的整体流程如下图：\n\n![1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png](https://pic.code-nav.cn/post_picture/1626574509983178753/uL6iuM5N-1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png)\n\n### 依赖\n\n除了 SpringSecurity 的相关依赖外，还需要 Redis 和 hutool （强大且全面的工具包，本篇文章中 JWT 的相关类也来自该包） 的依赖。\n\n```xml\n<!-- springboot整合的redis依赖，里面集成了 spring-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.13</version>\n</dependency>\n```\n\n### 配置\n\n在整个流程中，我们用到了 SpringSecurity + JWT + Redis ，需要配置的是SpringSecurity 和 Redis。\n\n##### SpringSecurity 配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Resource\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 注入 AuthenticationManager 对象，用于调用认证方法\n     *\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 放行登录接口\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 关闭csrf\n                .csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // 把jwt过滤器放到UsernamePasswordAuthenticationFilter前,便于先判断用户是否登录,再决定是否登录\n                .authorizeRequests()\n                // 对于登录接口允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n}\n\n```\n\n在配置类中，我们注入了 AuthenticationManager 对象。这个对象在上篇文章我们提到过，用于调用认证方法。但是在父类 WebSecurityConfigurerAdapter 中并没有将它注入到容器中，而我们又需要在自己的登录接口中调用它，因此需要重写 authenticationManagerBean 方法并将返回的对象注入到容器中。\nconfigure(HttpSecurity http) 方法用于配置路由，只开放登录接口，其他接口都需要认证。\n\n##### Redis配置\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        // 设置序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(\n                Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置redisTemplate\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n        RedisSerializer<?> stringSerializer = new StringRedisSerializer();\n        redisTemplate.setKeySerializer(stringSerializer);// key序列化\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化\n        redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n\n\n```\n\n在 Redis 配置中大部分是常规的序列化配置，特殊的是 ObjectMapper ，这个配置是为因为存储在 Redis 的实体类中除了成员变量的 get 方法外，其他方法不能有返回值，否则会导致反序列化异常，而 ObjectMapper 就是为了解决这个问题。\n反序列化异常的问题可以通过下面的代码验证\n\n```java\n@Test\npublic void test(){\n    RedisTestEntity entity = new RedisTestEntity();\n    entity.setName(\"111\");\n    redisTemplate.opsForValue().set(\"name\", entity);\n}\n\n@Test\npublic void get(){\n    Object name = redisTemplate.opsForValue().get(\"name\");\n    System.out.println(name);\n}\n\n@Data\npublic class RedisTestEntity {\n    private String name;\n\n    public Integer requireAge(){\n        return 18;\n    }\n}\n```\n\n### 定义登录接口\n\n##### 参数的接收\n\n```java\n@Data\npublic class UserLogin {\n    private String username;\n    private String password;\n}\n```\n\n##### controller部分\n\n```java\n@PostMapping(\"/login\")\npublic R<String> login(@RequestBody UserLogin userLogin){\n    String jwt = securityService.login(userLogin);\n    return R.success().data(jwt);\n}\n```\n\ncontroller 只是负责匹配路由和返回数据，业务通过 service 的相关方法完成，因此 controller 中没有太多代码\n\n##### service部分\n\n```java\n@Resource\nprivate AuthenticationManager manager;\n@Resource\nprivate RedisTemplate redisTemplate;\n@Override\npublic String login(UserLogin userLogin) {\n    Authentication userAuthentication = new UsernamePasswordAuthenticationToken(userLogin.getUsername(), userLogin.getPassword());\n    Authentication authenticate = manager.authenticate(userAuthentication);\n    // 如果认证成功则进入生成token的逻辑\n    if (authenticate.isAuthenticated()) {\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        SysUser user = loginUser.getUser();\n        // 将登录成功的对象存入redis\n        redisTemplate.opsForValue().set(KeyUtil.getLoginUserKey(user.getUserId()), loginUser);\n        // 生成token\n        String token = JWT\n                .create()\n                .setPayload(userLoginId, user.getUserId())\n                // (签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n                .setIssuedAt(new Date())\n                // 过期时间七天\n                .setExpiresAt(new Date(System.currentTimeMillis() + DateUnit.WEEK.getMillis()))\n                // // 设置HS256为加密算法，以用户的密码为盐（密钥）\n                .setSigner(\"HMD5\", salt.getBytes(StandardCharsets.UTF_8))\n                .sign();\n\n        return token;\n    }\n    throw new RuntimeException(\"用户名或密码错误\");\n}\n```\n\nservice 完成了登录的主要流程，包括：\n\n1. 调用 AuthenticationManager 实例的 authenticate 方法对用户的账号密码进行验证，该方法会调用到我们上篇文章自定义的方法，通过查询数据库的数据完成校验\n2. 如果校验成功，则将用户信息存入 Redis 并生成相应 token ，同时将用户 id 存入 token 的荷载中，失败则抛出异常\n\n### 登录过滤器\n\n完成登录后，在以后的每次请求都需要在请求头中带上 token 以便于认证，认证操作通过过滤器完成（关于 jwt 的具体知识本篇文章不做探讨，不熟悉请自行查阅相关资料）。\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"token\");\n        // 没有token，去走登录流程\n        if (StrUtil.isBlank(token)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // token不能为空\n        JWT jwt = JWTUtil.parseToken(token);\n        // 验证token是否合法\n        HMacJWTSigner singer = new HMacJWTSigner(AlgorithmUtil.getAlgorithm(\"HMD5\"), salt.getBytes(StandardCharsets.UTF_8));\n        boolean common = jwt.verify(singer);\n        // 验证时间，失败会抛出异常\n        try {\n            JWTValidator.of(jwt).validateDate(DateUtil.date());\n        } catch (ValidateException exception) {\n            throw new TokenInvalidException(\"token异常\");\n        }\n        if (common){\n            NumberWithFormat userIdObj = (NumberWithFormat)jwt.getPayload(userLoginId);\n            Integer userId = userIdObj.intValue();\n            LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(KeyUtil.getLoginUserKey(userId));\n            // 如果用户不存在，说明token异常\n            if (loginUser == null) {\n                throw new TokenInvalidException(\"token异常\");\n            }\n\n            // 将用户信息存入 SecurityContextHolder ，以便本次在请求中使用\n            UsernamePasswordAuthenticationToken authenticationLoginUser = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n            SecurityContextHolder.getContext().setAuthentication(authenticationLoginUser);\n\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n```\n\n我们自定义的过滤器类继承了 OncePerRequestFilter 类并重写了 doFilterInternal 方法，然后在 SpringSecurity 的配置类中将其添加到 UsernamePasswordAuthenticationFilter 前面（校验账号密码之前），对应配置类中的如下代码\n\n```java\nhttp.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n在过滤器中，我们首先校验了 token 是否存在。如果不存在则直接放行，然后在后续校验权限时会被自动拦截下来。存在则验证 token 的合法性，通过后从 token 拿到用户 id ，从 Redis 中获取到用户信息，如果不存在说明用户的登录状态异常（可能是退出了登录状态，后文会说）。从 Redis 中取到用户信息后，就可以将用户信息存到 SecurityContextHolder 中，方便后续进行认证、授权以及使用。最后放行，执行后续操作。\n\n### 退出登录\n\n在做完前面的操作后，退出登录的操作就很简单了。\n\n```java\n@PostMapping(\"/logout\")\npublic R<String> logout(){\n    Boolean delete = securityService.logout();\n    return R.success().data(delete);\n}\n```\n\n```java\n@Override\npublic Boolean logout() {\n    LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Integer userId = loginUser.getUser().getUserId();\n    Boolean delete = redisTemplate.delete(KeyUtil.getLoginUserKey(userId));\n    return delete;\n}\n```\n\ncontroller 和 service 的代码分别如图。\n在 service 中我们删除了 Redis 中的用户信息，这也就解释了为什么过滤器中会存在 token 合法但是用户信息不存在的情况（退出登录），当然也可能有其它的特殊情况。\n\n### 结语\n\n本篇文章就到这了，下一篇应该是关于授权的内容，我们下次再见。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 27,
        "thumbNum": 1,
        "favourNum": 2,
        "commentNum": 0,
        "priority": 0,
        "userId": "1626574509983178753",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T13:35:26.000+00:00",
        "updateTime": "2023-05-07T02:21:31.000+00:00",
        "user": {
          "id": "1626574509983178753",
          "planetCode": "452",
          "userName": "松柏",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1626574509983178753/ExDo1T3f-wallhaven-72rxqo.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T11:07:05.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-17T13:29:18.000+00:00",
          "updateTime": "2023-05-06T10:10:34.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Redis"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654479553654992898",
        "title": "初识 Spring Security",
        "description": null,
        "content": "### 前言\n\nSpring Security 是什么呢，在官网里时这样描述的\n\n> Spring Security是一个框架，提供 认证（authentication）、授权（authorization） 和 保护，以抵御常见的攻击。它对保护命令式和响应式应用程序有一流的支持，是保护基于Spring的应用程序的事实标准。\n\n简而言之就是一个安全框架，能够很好的保护我们的 Spring 应用\n\n### Spring Security执行流程（简化）\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1626574509983178753/NDLHc9LJ-image.png)\n（图来自B站：三更草堂）\n从图中可以看到，用户输入的用户名密码会被一路传到 DaoAuthenticationProvider（后文简称 DAP ）， 然后由 InMemoryUserDetailsManager （实现了 UserDetailsService 接口）根据用户名从内存中查找到对应的用户信息并返回给 DAP 。 DAP 将查到的信息与用户输入的信息进行比对，如果正确则返回并存储认证对象（没有json返回值）。\n\n### 整合数据库\n\n上面提到，Spring Security 默认是在内存中查找用户信息，这是不符合我们实际开发的场景的。我们需要从数据库中查到真实的用户信息。\n这时候就需要用到 UserDetailsService 接口，因为最后查找用户的操作是由该接口定义的，我们只需要实现该接口并实现 loadUserByUsername 方法，即可实现从数据库中查找用户信息。\n\n```java\n    @Resource\n    private SysUserService sysUserService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = sysUserService.getUserByUserName(username);\n        if (user == null) {\n            throw new RuntimeException(\"账号或密码错误\");\n        }\n        LoginUser loginUser = new LoginUser(user);\n        return loginUser;\n    }\n```\n\nloadUserByUsername 方法要求返回的 UserDeatils 对象是 Spring Security 的内置用户对象，我们可以通过组合的方式将查出的用户封装为 UserDeatils 对象。\n\n```java\npackage com.cowz.databasedemo.entity.security;\n\nimport com.cowz.databasedemo.entity.SysUser;\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private SysUser user;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUsername();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n其中 SysUser 就是我们系统中的用户对象。\n\n### 密码加密器\n\n做完以上操作在进行测试时，会报一个异常\n\n```java\njava.lang.IllegalArgumentException:There is no PasswordEncoder mapped for the id \"null\"\n```\n\n这是由于没有配置密码加密器所引起的，密码加密器确保我们的密码在数据库中是以密文而不是明文存储的。为此我们需要进行以下的配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 14,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1626574509983178753",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T13:33:59.000+00:00",
        "updateTime": "2023-05-07T02:22:23.000+00:00",
        "user": {
          "id": "1626574509983178753",
          "planetCode": "452",
          "userName": "松柏",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1626574509983178753/ExDo1T3f-wallhaven-72rxqo.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T11:07:05.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-17T13:29:18.000+00:00",
          "updateTime": "2023-05-06T10:10:34.000+00:00"
        },
        "tags": [
          "文章",
          "Spring",
          "后端",
          "安全"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654376152560611329",
        "title": "RPC原理与实现",
        "description": null,
        "content": "\n## 什么是RPC？\n\nRPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。\n\n那么我们至少从这样的描述中挖掘出几个要点：\n\n- RPC是**协议**：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。\n- **网络协议和网络IO模型对其透明**：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。\n- **信息格式对其透明**：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。\n- **应该有跨语言能力**：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。\n\n\n![image-20230413134629079.png](https://pic.code-nav.cn/post_picture/1626450481553383425/xfh5e0hA-image-20230413134629079.png)\n\n那要怎样实现透明化远程调用呢？要让开发者无感知的调用远程方法呢？答案就是动态代理！！！\n\n动态代理会通过反射获取到远程服务的接口，当执行本地方法时就会调用`invoke`方法，进行通信相关逻辑，最后成功调用。所以还记得为什么要在进行远程调用的时候消费者和服务者都要定义接口信息，所以**公共模块就可以把Service的接口提取出来**。\n\n### 什么是动态代理\n\n虽然上面说到需要用到动态代理，但是这个玩意儿到底是个啥，所以这里也可以简单聊一聊。\n\n代理其实是一种结构性`设计模式`。可以控制对类对象的访问，在访问类对象时增加额外功能。类似与下图所示，代理会获取到当前接口的实现类，并在其基础上进行增强。\n\n![image-20230413125527475.png](https://pic.code-nav.cn/post_picture/1626450481553383425/X8ceMVbZ-image-20230413125527475.png)\n\n而代理又分为静态代理和动态代理，他们的区分方式是`代理关系是否在编译期确定`。\n\n#### 静态代理\n\n就比如现在想去租房，然后现在只有中介手里才有房源，所以你就可以跟中介进行沟通，而不用去直接和房东沟通。因为在编译期就知道了代理关系，所以是静态代理。通俗的来讲就是你事先知道这个中介是买房子的。\n\n但是静态代理存在一定的缺陷，`重复性`：随着业务的增加需要编写很多模板代码，也就解释了为什么不适用静态代理实现RPC框架。`脆弱性`：一旦基础接口改动，代理类也需要同步修改。\n\n#### 动态代理（通用+兼容多个业务）\n\n同样是中介，只不过这次的中介是拼命三郎，一天打n份工，不仅卖房，还卖车，还卖酒，各种。。。也就是说在联系之前，我们是不知道它卖的是什么？但是见面之后你告诉他需求，他就能帮你找到！是不能提前知道代理关系，所以是动态代理。\n\n动态代理一般有JDK、CGLIB、JavaScript几种实现方式。这里只讨论JDK。它可以利用反射机制在运行时生成的类的字节码，主要是利用Invoke函数去直接访问基础对象，另外也可以通过使用泛型来实现兼容多个业务接口。\n\n对比来看！静态代理就是提前确定一个类，需要把所有的类都提前确定，而动态代理则是可以将类细节隐藏，同时负责多个接口。另外静态代理的类字节码是在编译期就确定的，而动态代理则是在运行时生成的。他们的相同点就是可以不修改原来的对象，只是自己新创建一个对象进行扩展。但重点是控制对于原有对象的访问。\n\n> 这里额外的进行一个扩展，刚刚提到的代理模式，是不是与装饰器模式特别像，至少在功能扩展上是的吧\n> 装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。\n>\n> 1. 代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。\n> 2. 装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；\n> 3. 装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；\n\n解释清楚了什么是动态代理，那么中间有提到反射，这又又又是一个技术深入的点。\n\n### 什么是反射\n\n刚才有提到利用反射获取的类的字节码。是的，反射的作用就是在运行时动态的获取类。\n\n在开始之前，先来梳理一下Java的类型模型，首先Java是一个强类型语言，就是变量有固定的类型。另外Java是一个静态语言，即类型检查更偏向于编译时执行，但是也不全部都是，Java有时也会在运行时进行类型检查，比如Object对象的类型检查。\n\n现在想象一下Python在进行变量的创建与接收的时候不用判断类型，同样的，Java通过`反射`也拥有了这样的特性。我们可以直接获取类的对象，进而获取其全部属性。\n\n实质上，反射的实现就是将生成的Class对象直接拿到内存来用，通过Native方法来实现这个过程，而当反射执行次数较多时，通过ASM字节码生成新的类，并将以后的反射委派给新类。\n\n## RPC的实现\n\n讲完了RPC的原理，接下来就是它的实现方式。\n\n常见的几种实现方式包括`grpc` `Thrift` `Dubbo`,这里主要通过DUBBO来实现RPC。官网上是这样说的，提供**高性能通信**和**服务治理**能力的微服务开发框架。\n\n### 高性能通信\n\n#### 高性能数据传输\n\n内置支持Dubbo2、Tripe两个高性能通信协议\n\n- Dubbo2 是基于 TCP 传输协议之上构建的二进制私有 RPC 通信协议，是一款非常简单、紧凑、高效的通信协议\n- Triple 是基于 HTTP/2 的新一代 RPC 通信协议，在网关穿透性、通用性以及 Streaming 通信上具备优势，Triple 完全兼容 gRPC 协议\n\n#### 流式通信\n\n业务的迅速增长会使得集群规模增加，从而带来服务治理问题：\n\n- 注册中心的存储瓶颈\n- 节点动态变化地址推送与解析效率下降\n- 复杂网络链路管理\n\n### 服务治理\n\n#### 流量管控\n\nDubbo 丰富的流量管控规则可以控制服务间的流量走向和 API 调用，基于这些规则可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等，提高系统稳定性。\n\n#### 微服务生态\n\n具有较好的扩展机制，对于大多数服务治理需求都可满足，也可以通过扩展机制轻松适配。\n\nEmmm....感觉框架和应用大致了解一下设计思想，清除一下相关技术替代品，能够在合适的场景下用就好\n\n## Reference\n\n[JDK动态代理的原理其实很简答](https://juejin.cn/post/6974018412158664734)\n\n[反射机制](https://juejin.cn/post/6889833658669072397)\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1626450481553383425/xhQcqRz7-1f9187c7a5e94f8fab57c54a52b9fff0.jpg",
        "language": null,
        "viewNum": 19,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1626450481553383425",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-05T06:43:06.000+00:00",
        "updateTime": "2023-05-07T01:24:40.000+00:00",
        "user": {
          "id": "1626450481553383425",
          "planetCode": "16378",
          "userName": "beeran",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1626450481553383425/H1EQ2NWG-beeran.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": "广州大学",
          "major": "网络空间安全",
          "education": "一本",
          "graduationYear": 2024,
          "jobStatus": "求职中",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": "https://github.com/tc6-01",
          "blog": "beeran.space",
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-19T23:03:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-17T05:16:27.000+00:00",
          "updateTime": "2023-03-21T04:17:43.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1654008802426531841",
        "title": "送了老弟一台 Linux 服务器，它又懵了！",
        "description": null,
        "content": "大家好，我是鱼皮。\n\n前两天我学编程的老弟小阿巴过生日，我问他想要什么礼物。\n\n本来以为他会要什么游戏机、Q 币卡、鼠标键盘啥的，结果小阿巴说：我想要一台服务器。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417170739167.png)\n\n鱼皮听了，不禁称赞道：真是个学编程的好苗子啊，行，我就送你一台最低配的 Linux 服务器吧！1 核 1 G 的那种。\n\n小阿巴（感动）：我焯，谢谢哥，但为什么送我最低配的呢？\n\n鱼皮：对初学 Linux 的同学来说，一般不会部署特别大的项目，1 核 1 G 的服务器，无论是用来学习 Linux 命令，还是用来部署个人博客和小项目都已经足够了。后续如果需要用到更高的配置，再升级即可。\n\n小阿巴：原来如此，之前就听说有同学买了 Linux 服务器后，由于不会用，就积灰了。那我先拿这个机子学习！\n\n鱼皮：不错，你先自己摸索一下，就当平时的办公电脑一样用试试~\n\n\n\n1 小时后。。。\n\n鱼皮：怎么样，知道怎么使用 Linux 了么？\n\n小阿巴：阿巴阿巴。。。这服务器为啥没界面啊！我不懂玩。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417171533623.png)\n\n鱼皮：我送你的服务器安装的是 Linux 的一个发行版 —— CentOS 系统，默认是没有 Windows 和 Mac 那样的图形界面的，而是需要使用 `命令行` 来操作哦。\n\n小阿巴：！为啥 Linux 要这么设计啊，它为啥不像 Windows 一样用图形界面呢？\n\n鱼皮：这里其实是非常有考究的。正因为如此设计，不运行图形界面，能够大幅节省系统的资源，从而提高系统的 **资源利用率** ，运行更多的项目（程序）。而且 Linux 支持多用户远程登录，不运行图形界面也可以一定程度上保证系统的稳定性。\n\n高性能、低成本、更稳定，也是 Linux 服务器被广泛应用于生产环境部署项目的重要原因。\n\n小阿巴：原来如此，我可算知道为啥说程序员都要学习 Linux 了。那我现在应该怎么入门 Linux 呢？面对小黑框框我一脸懵逼啊。。。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417173242558.png)\n\n鱼皮：可以看下我之前写的 [Linux 学习路线](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247501290&idx=1&sn=05437a67ba6888eeab253e554b693ceb&chksm=e9c2221ddeb5ab0b8b3d01651fcf41cccf1f0e5e1304e8441bfad789eb92d57d06a72f624c1e&token=706151027&lang=zh_CN#rd) ，入门 Linux 首先要做的就是 **了解 Linux 的常用命令** ，能做到像用界面操作 Windows 一样灵活操作 Linux，那你就成功了！\n\n小阿巴：的确，好像我之前经常在别人的简历上看到 “了解 Linux 命令” ，那我应该了解哪些 Linux 命令呢？\n\n鱼皮：Linux 的常用命令可以分为几大类，简单给你介绍一下吧。\n\n\n\n### Linux 常用命令\n\n#### 文件操作命令\n\n> 学习优先级最高，Linux 一切皆文件\n\n- pwd：显示当前所在目录\n- ls：查看目录下的文件\n- mkdir：创建目录\n- cd：切换当前目录\n- mv：移动文件或目录\n- cp：复制文件或目录\n- rm：删除文件或目录\n- zip：压缩文件\n- unzip：解压文件\n\n\n\n#### 系统信息命令\n\n> 后端开发重点，可使用这些命令进行异常分析\n\n- top：查看进程及资源占用情况\n- ps：查看进程信息\n- free：查看内存占用情况\n- df：查看磁盘占用情况\n- ifconfig：查看网络接口信息\n- netstat：查看网络状态信息\n\n\n\n#### 文件查看命令\n\n> 后端开发重点，可使用这些命令快速定位项目日志中的异常信息\n\n- cat：查看文件内容\n- head：查看文件开头内容\n- tail：查看文件末尾内容\n- grep、sed、awk 三剑客：灵活查找和处理文件内容\n\n\n\n#### 用户权限命令\n\n> 一般是给 Linux 运维（管理员）使用\n\n- useradd：添加用户\n- userdel：删除用户\n- chmod：修改文件或目录权限\n- chown：修改文件或目录所有者\n\n\n\n鱼皮：当然，以上只是 **部分** 常用命令，Linux 还有很多实用的第三方库和命令，感兴趣可以自己探索下~\n\n小阿巴：谢谢鱼皮，我这就去学习命令，背单词我最擅长！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417173707444.png)\n\n鱼皮：记住，学 Linux 命令不要去死记硬背！把每个命令都敲几遍，有个大概的印象，后面部署项目的时候多操作下自然就熟悉了。像我们在工作中，也不会刻意去背这些命令，如果忘记了某个命令的用法，可以直接用 `命令 --help` 快速查看帮助文档，或者通过 Linux 命令集网站查询即可，比如：https://www.linuxcool.com/。\n\n小阿巴：谢谢，我刚刚查到一个命令： `rm -rf /*` ，这就去试试！\n\n鱼皮：住手啊！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230417175215280.png)\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 74,
        "thumbNum": 6,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-05-04T06:23:23.000+00:00",
        "updateTime": "2023-05-07T01:27:25.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 601,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-06T10:09:53.000+00:00"
        },
        "tags": [
          "文章",
          "Linux",
          "服务器"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1650765376411185154",
        "title": "我们公司的面试，有点不一样！",
        "description": null,
        "content": "朋友们周末愉快，我是鱼皮。因为我很屑，所以大家也可以叫我屑老板。\n\n自从我发了自己创业的文章和视频后，收到了很多小伙伴们的祝福，真心非常感谢！\n\n不得不说，有些同学是真有才啊，因为我公司叫 “鱼鸢网络”，就有同学把它称为 “鱼厂”。那 “鸢”（yuan）还有鸟的意思呢，可以考虑叫 “鸟厂” 哈哈？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422215203253.png)\n\n言归正传，开了公司后，我收到最多的评论和私信就是：鱼厂公司什么时候招人？公司是怎么招人的？\n\n其实之前我也说了，我们公司的员工在我离职前就已经招好了，今天给大家分享一下我们公司招开发的过程。\n\n不能说是史无前例，但也绝对和大多数公司的招聘方式不一样。\n\n**因为，我们不仅没有笔试！也没有面试！**\n\n为什么呢？这里就要先说一下我的招人标准了，用五个字来概括就是 “要能干好活”。\n\n说白了，就是我要知道这个求职者不仅能够完成我的工作、完成我们项目的需求；还要态度认真、做事仔细，能把工作完成的很好，不能一上线就一堆 Bug。\n\n那我就在思考，怎么样才能保证自己招到的人符合这个要求呢？\n\n我的策略很简单：\n\n目标 1：我要足够了解这个人，确保他的做事态度是认真的\n\n策略：从我 [编程导航知识星球](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=145986907&lang=zh_CN#rd) 里的同学招募，因为首先星球里的人学习态度都很认真，而且可以直接根据他在星球里的往期发文来看出他个人的学习态度和做事风格\n\n目标 2：我要确认他能够完成项目开发工作\n\n策略：区别于传统的笔试和面试题目，我直接在星球发布一个实际工作中可能要做的小项目（小问题）给大家去完成，根据大家的解决方案、作品和代码来综合评估大家的项目能力。\n\n我不管你的学历如何、不管你八股文背的怎么样，只要你能够认真地完成我们项目的需求、能干好活，就足够了。\n\n确定了这两个策略，我就在星球里发布了两个招募帖：\n\n前端招募：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422214517713.png)\n\n前端考核任务：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422214535875.png)\n\n后端招募：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422214615327.png)\n\n大家也可以思考一下这两个考核任务自己能否完成，应该难度是不大的，星球里完成的同学也不少。但毕竟我们招募人数有限，“完成” 和 “做得好”，我们当然要后者。\n\n最终我成功招募到了前端开发同学。但可惜的是，后端开发同学还没有招到满意的，近期很可能还会在星球发一个后端实习生的招募，招募方式应该也是类似的。到时大家如果感兴趣的话，欢迎来尝试！\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 169,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-25T07:35:10.000+00:00",
        "updateTime": "2023-05-06T09:36:44.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 601,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-06T10:09:53.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1650453555540176897",
        "title": "炸裂的 AutoGPT，鱼皮教你免费用！",
        "description": null,
        "content": "大家好，我是鱼皮，继前段时间爆火的 ChatGPT 后，又一个炸裂的开源项目 `Auto-GPT` 出现了。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423130304295.png)\n\n仅在最近 10 天，这个项目就收获了 8 万多个 star，目前总 star 数超过 10 万！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423130209755.png)\n\n那 Auto-GPT 到底是个什么玩意？它到底凭什么这么火？如何使用和部署它？它到底真的实用么？\n\n带着这些问题来看这篇文章，下面我就给大家分享下 Auto-GPT 的介绍、最简单的部署方法、并且做一个简单的上手体验。\n\n> 本文对应视频教程：https://www.bilibili.com/video/BV1ho4y1b75o/\n\n\n\n### 什么是 Auto-GPT？\n\nAuto 即自动，Auto-GPT 就表示自动的 GPT。\n\n什么意思呢？\n\n以前假如我们想使用 ChatGPT 来写一篇论文，可能要 **人工** 问它好几个问题，比如：\n\n问：我想写一篇关于 AI 的论文，我需要怎么做？\n\nAI 答：确认选题、写背景、写程序、写实验、写总结等。\n\n问：帮我想 1 个选题\n\nAI 答：AutoGPT\n\n问：帮我介绍下 AutoGPT 的背景\n\n。。。\n\n你需要多次人工地向 AI 提问，直到你最后完成一篇论文。\n\n但有了 AutoGPT，你只需要告诉它一个目标，比如 “写一篇关于 AI 的论文”，它就能够用程序全自动地完成目标。\n\n当然，和人类一样，它也不是一步到位的，而是先自动向 AI 提问，然后根据 AI 的回答再自动提出新的问题，如此循环往复直到达成你告诉它的目标。\n\n> AutoGPT 本身也是结合了 LLM 大语言模型，相当于让 AI 来指挥 AI。\n\n此外，AutoGPT 还有个很 \uD83D\uDC02 的能力，当它发现 GPT 无法回答他的问题时，会主动到网上搜索答案，这样就弥补了 GPT 训练数据只到 21 年 9 月的不足。\n\n![官方介绍的特性](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423131622842.png)\n\n听上去感觉很厉害，那接下来我们就来整一个自己的 Auto-GPT 吧~\n\n\n\n### 搭一个自己的 Auto-GPT\n\n网上很多教程都是让大家在自己本地搭建 Auto-GPT，其实是不推荐的，不仅麻烦，而且可能存在环境、依赖不一致的情况。\n\n个人认为最简单的方式是使用 `GitPod` 云托管服务，直接用别人提供的服务器来部署 Auto-GPT，用来学习再好不过了。\n\n首先访问官方仓库：https://github.com/Significant-Gravitas/Auto-GPT\n\n然后点击 Fork，复制仓库到自己的 GitHub 中：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132110893.png)\n\n这一步千万要注意！取消勾选 `Copy the master branch only` ！因为 `master` 分支的代码可能是不稳定的（我就翻过车）！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132346281-20230423132737947.png)\n\nFork 成功之后，我们进入到自己的仓库中，然后把浏览器地址中的 `github.com` 改为 `gitpod.io/#` 。\n\n比如我的是地址： `https://github.com/liyupi/Auto-GPT `，改成 `https://gitpod.io/#/liyupi/Auto-GPT` ，然后访问，现在就可以一键用 GitPod 来部署项目了！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132605882.png)\n\n然后我们就进入到了 GitPod 项目主页，大家现在就可以把这个网页当做自己的电脑（服务器）来使用了，比如使用 VS Code 编辑器。\n\n进到这个页面后，第一件事是切换分支，一定要选择 `origin/stable` 分支！否则后面说不定遇到什么奇奇怪怪的 Bug。\n\n如下图：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132829674.png)\n\n然后，我们在左侧目录中找到 `.env.template` 文件，右键修改文件名为 `.env` ，并且修改 OPEN_API_KEY 为自己的。\n\n> 因为 Auto-GPT 底层也是向 OpenAI 提问的，所以必须要有 OpenAI 的 key。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423133223230.png)\n\n修改完成后，在终端中输入 `./run.sh` 命令，就会自动安装所需环境和依赖，等着就好~\n\n看到下图中的消息，就表示安装成功了！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423134311912.png)\n\n然后我们按 `ctrl + c` 退出程序，以后不要用 `run.sh` 命令启动了，因为每次都要检查依赖，我们可以直接用 `python -m autogpt` 命令来启动 autogpt。\n\n比如执行 `python -m autogpt --help` ，查看 autogpt 的用法和参数说明： \n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423134614047.png)\n\n上图中，有几个参数是需要额外关注的，比如：\n\n- -c：是否开启连续模式。这是一个非常危险的命令！表示 autogpt 会不经过你的同意全自动执行，包括但不限于死循环、无限创建文件、占满空间后删除你电脑上的文件等等。就和人类一样：可能会为了达到目的不择手段！\n- -l：指定连续执行的次数限制。可以防止死循环。\n- --speak：开启语音模式。但不是说在浏览器内部播放声音，而是生成音频文件。\n\nOK，了解了这些后，我们来体验一下~\n\n\n\n### 牛刀小试\n\n就给一个很简单的任务吧，让 autogpt 帮忙 “写一个网站，赞美一只鸡在打篮球”。\n\n首先执行 `python -m autogpt` 命令，然后依次输入 AI 名称、AI 角色和目标：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423135414380.png)\n\n然后 autogpt 就屁颠儿屁颠儿去工作了，我们可以看到他的想法、计划和下面要做的行动。比如他打算到网上搜索更多信息，使用 Google 搜索命令。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423135450228.png)\n\n我们可以输入 `y` 表示同意他这么做，也可以输入任何内容和建议来影响他的操作。\n\n这里我就同意他吧~\n\n然后呢，这货竟然说要看网上的视频来学习！好家伙，AI 也要摸鱼？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423135754861.png)\n\n同意之后，他直接就下载视频文件了，结果没想到因为我的服务器上没有浏览器，他看不了视频！只能再倒回去 Google 搜索。\n\n那我们再输入 `y` 表示同意：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140026739.png)\n\n结果你猜怎么着，他又想去看视频！已经陷入循环了。。。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140059101.png)\n\n所以可想而知，如果你让 autogpt 全自动跑一天，除了你的 OpenAI Key 余额被消耗完之外，说不定没有任何的成果。\n\n所以人类必须要出手了，我让它：不要再看视频了，任何文本都行！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140425183.png)\n\n结果呢。。。它表示要去浏览其他的网页，不听话啊！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140251942.png)\n\n所以我态度只能再强硬一点！“停止调研，立刻给我开发网站！”\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140555673.png)\n\n这次他听话了，而且计划执行 `write_to_file` 命令生成了网站：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140529400.png)\n\n输入 `y` 表示允许，然后他就帮我们在工作空间下生成了 `index.html` 文件：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140758809.png)\n\n网站生成完毕！让我们本地打开验证一下，看到了如下的文字 “鸡不仅能用来吃，他们也会打篮球”。并且分享了一篇文章和一个视频！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140912174.png)\n\n视频来源于 youtube，点开视频，我笑疯了：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423141103354.png)\n\n虽然有点投鸡取巧，但不管怎么样，autogpt 也算是在短时间内完成了一个网站吧，还是很不错的！\n\n不过完成这个网站后，autogpt 并没有停止的意思，依然执着地在 youtube 搜索鸡打篮球相关的视频。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423141254699.png)\n\n所以朋友们，连续模式是真的危险，AI 如果脱离了人的控制，也是真的危险啊！\n\n> 我的编程导航网站：[https://www.code-nav.cn](https://www.code-nav.cn)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 140,
        "thumbNum": 2,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-24T10:56:06.000+00:00",
        "updateTime": "2023-05-06T09:54:30.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 601,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-06T10:09:53.000+00:00"
        },
        "tags": [
          "文章",
          "人工智能",
          "工具"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1650435414638505986",
        "title": "如何写好工作总结？",
        "description": null,
        "content": "进了公司后，我们难免会被要求写一些工作总结，而且上级很可能会根据你的工作总结来评估绩效、决定是否升值加薪。因此，写好一份工作总结是至关重要的。\n\n像我们鹅厂这边，每半年会有一次绩效考核，考核前要求我们每位员工和基干都要写一个自评（自我评价），其实就是对自己近半年来的工作总结了。比如你这半年做了哪些工作、之前定制的目标完成的怎么样了、给项目 / 团队 / 公司带来了哪些贡献等等。\n\n虽然有些同学说：领导要给你什么样的绩效早就心里有数了，写自评就是意思意思。但我每次还是会认真写自评的，一方面是希望在老板那里有一点点的加分；另一方面也是写给自己看的，希望通过对自己近半年工作的回顾，帮助自己发现问题并改正、持续进步吧。\n\n朋友们也知道我是一名 UP 主，这两年来我基本每天都会写文章，平均每天的文章码字量都是 3000 字以上，也积累了一些写作小技巧，所以写这些总结什么的还是很快的。\n\n下面就给大家分享一下我写工作总结的经验方法，帮助大家在面对一大堆零散的工作资料、或者完全没有头绪的时候快速写出一篇漂亮的总结。\n\n主要分为几个步骤：\n\n### 零、原始素材\n\n跟做视频一样，我们写工作总结前肯定是需要原始素材的，比如你这半年工作都干了啥？\n\n那么原始素材从哪里来呢？\n\n#### 日常积累\n\n首先是平时工作的 **日常积累** 。就好比你期末考试复习一样，平时认真听课、持续学习、定期复习，那么考试前只需要再过一遍知识点就好了；但如果你之前一点儿都没有学习记录，那考试周就只能无比痛苦地预习。\n\n所以建议大家养成每日记录工作的好习惯，比如自己今天做了什么、哪里做的好、哪里做的不好、有什么需要注意的地方等等；并且每周或者每月定期对这些工作进行汇总，分析一下自己这个月的工作情况、成长与不足，这些都会成为你写总结的 **原始素材** 。此外，定期总结也能够提前发现一些工作上的问题：比如你发现自己这个月天天在写增删改查，毫无成长，那么也可以考虑一下如何改进、减少重复工作；或者利用业余时间提升自己，准备跑路。\n\n由于平时我每天都会记录自己的工作内容（我们疫情居家办公期间还要求写日报发到群里），并且每周开周会前都要再对这周的工作进行汇总，再加上我还专门维护了一个文档来记录自己工作或项目中的亮点，因此只花了一个小时左右就写完自评总结了，非常轻松。\n\n所以朋友们，日常积累真的是非常重要的！大家感兴趣的话，可以看看 [鱼皮的打工日记](https://wx.zsxq.com/dweb2/index/tags/鱼皮的打工日记/48848428221188) ，也可以像鱼皮一样持续记录自己每日的工作和生活，之后再回过头来看看，那都是自己的财富。\n\n#### 工作历史\n\n如果平时没有养成记录工作的习惯，也没关系，现在我们都是用电脑来办公，虽然人没记，但是机器的硬盘会帮我们记忆呀！\n\n比如翻翻你和产品 battle、或者和用户扯皮改 Bug 的聊天记录；翻翻你的浏览器访问记录找找历史需求文档；或者翻翻你的代码提交记录；再不行就问问你的同事“这半年我都做了啥？”。总归是能找到一些蛛丝马迹的。\n\n有了原始素材后，我们的准备工作就算做完了，可以正式开始写总结啦。\n\n\n\n### 一、列举目标\n\n写文章时，每篇文章一定要有明确的主题；同理，工作总结一定是要围绕着目标去写的，而不是真的把自己每天工作改 Bug 这些事写上去。比如通过做了哪些事，完成了 xx 目标，或者进度达到了百分之多少等。这样老板才能最直接了当地 get 到你工作的情况和进展。大家的工作一般是不会缺少目标的，如果自己没有定目标的话，那就想想公司的目标、组内的目标，想想老板年初时给你们画的饼、或者参考下老板的目标等等。目标要能体现出自己的价值，但也不能太大，要符合实际。\n\n像我这次写总结时，就先大致地回想了一下自己近半年的工作，并且按照年初时定制的目标分为了几个大类。比如这半年我要：\n\n1. 建设 A 项目，提高 xx\n2. 改造 B 项目，提高 xx\n3. 快速上手 C 项目，能独当一面等\n\n\n\n确定目标后，就相当于确定了你总结的几个主题。每个目标可以作为一个小标题，接下来的内容就围绕着这些目标去写，不容易出现偏航和流水账。\n\n\n\n### 二、填充工作\n\n这一步最简单，打开我们所有的原始素材，回顾自己从年初一直到今天的工作内容，然后从上到下依次把每一条工作内容无脑复制粘贴到对应的目标下面即可（当然，没完成或者太水的工作要过滤掉）。整个过程几乎不需要任何思考，纯体力劳动，你甚至可以边听 rap 边整理。\n\n举个例子，有一天的工作是：\n\n1. 开发 A 项目的 xx 功能\n2. 优化 B 项目的 xx 性能，减少 20% 的首屏加载时间\n3. 阅读 C 项目相关文档\n\n那我就先把第一条工作内容复制到目标 A 下，第二条工作复制到目标 B 下，第三条工作复制到目标 C 下，就这么简单。\n\n\n\n### 三、合并工作（Merge）\n\n第二步完成后，估计你的每个目标下都有一大堆的工作，肯定不可能都写到自评上对吧（那样就成流水账了）。所以接下来我们就要把相似的工作进行合并，这里提供两种合并的方式：可以按照需求类型合并，比如是业务需求还是技术优化 ；也可以按照成果合并，比如提升了系统的性能，还是提高了项目收入，还是减少了成本。\n\n\n\n举个例子，目标 A 下本来有 4 个工作：\n\n1. 开发 A 项目功能 1\n2. 开发 A 项目功能 2 \n3. 优化 A 项目稳定性\n4. 优化 A 项目可用性 \n\n\n\n可以合并为：\n\n1. 新增功能：1、2。即按需求类型合并，都是新增功能。\n2. 优化 A 项目的稳定性和可用性。按成果合并，都是对项目的优化。\n\n\n\n### 四、浓缩为精华\n\n即使对工作进行了合并，一般也不建议直接写到自评上，因为只列举工作会显得很机械、很流水账。所以我们还要对一大段的排比或者工作的列举进行浓缩和润色，将每个目标下的内容分别浓缩为几句精华。\n\n就拿上面合并后的内容来说吧，最终可能会被润色为这样一句话：近半年来，我多次主导 A 项目的方案设计和功能实现，比如功能 1、2，并多次超前完成交付，得到了用户的好评。最后再补充一张用户反馈好评的截图，增加可信度。\n\n最后基本上每个目标下的工作都能浓缩为 1 - 2 句话，整个自评看起来就比较有料、也没有任何多余的内容。\n\n\n\n------\n\n\n\n整个写总结的过程大概就是这样，其实就像我们做大数据处理一样。先采集原始数据（工作积累）并确定数据处理的重点（工作目标），再对数据进行清洗（过滤掉无意义的、重复的、过于水的工作），再将数据分组（按目标分类）和合并（把同一目标下的工作并在一起），最后再进行聚合（汇总目标下的工作为精华）。\n\n整个流程的关键其实在于工作的积累。因此我们平时一定要认真工作、积极产出、持续记录总结，做到有东西可写，最后写出来的总结才会是货真价实的金玉。我们的工作能力和写总结的水平也是需要一点一滴积累才能提升的，大家一起加油吧！",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 59,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-24T09:44:01.000+00:00",
        "updateTime": "2023-05-06T05:57:00.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 601,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-06T10:09:53.000+00:00"
        },
        "tags": [
          "文章",
          "经验分享"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1650434425369964545",
        "title": "写简历问题汇总",
        "description": null,
        "content": "> by [程序员鱼皮知识星球](https://yupi.icu)，请勿对外公开！！！\n\n\n\n鱼皮花了整整 4 个晚上，对最近改过的几百份简历进行了逐一分析和梳理，最终整理出了一份大家写简历时经常出现的问题汇总文档，多达 50 多个高频问题！\n\n\n\n希望大家写简历前，都能一字不差地读完一遍这些问题，相信能够帮大家提升简历回复率。\n\n\n\n### 1、整体\n\n\n\n#### 1.1 简历篇幅过长\n\n\n\n建议：一般校招简历以 **一页纸** 为最佳，保证面试官有耐心看下去。但注意，并不是说强制一页纸，只是希望大家在简历上突出重点、惜字如金，而不是像记流水账一样什么都写。如果你能写的内容就是很多的（比如冲击大厂、工作 3 年以上、求职等级较高），那么一页纸以上完全没问题。\n\n\n\n#### 1.2 简历缺少 XX 板块\n\n\n\n建议：一份完整的程序员简历包含个人信息、教育背景、专业技能、荣誉奖项、工作经历、项目经历、科研经历、校园经历、个人优势等内容。\n\n\n\n其中，个人信息、教育背景、专业技能、项目经历是 **必须具备** 的！\n\n\n\n#### 1.3 简历篇幅不够合理\n\n\n\n建议：合理分配各部分内容占用的篇幅，推荐的占比如下：\n\n\n\n- 个人信息 5 ~ 10%\n- 教育背景 10 ~ 15%\n- 专业技能 20 ~ 30%\n- 项目经历 30 ~ 40%（工作 / 校园 / 科研等经历也算在内），对绝大多数同学来说，这部分是 **核心** ！\n- 其他内容 0 ~ 20%（比如奖项、个人优势等）\n\n\n\n总之，尽量多写经历来体现自己的实践能力、解决问题的能力，少写一些正确的废话（自我评价）。\n\n\n\n#### 1.4 简历模板不够整洁\n\n\n\n建议：一份优秀的简历必须在 **外观和内容** 上都很出色，做到秀外慧中。所以，挑选一个好的简历模板是至关重要的！\n\n\n\n简历的板块划分要清晰、排版要整洁、内容不要太挤或太空；色调不宜过暗或过亮，推荐蓝色或淡灰色；色彩不要太丰富，要让人看起来舒服。\n\n\n\n可以尝试鱼皮自己用过的、非常精简整齐的免费简历模板：https://www.wondercv.com/jianlimoban/jqZb6WM.html\n\n\n\n当然也可以尝试其他模板，只要保证简历的整体结构是从上到下、布局清晰、排版整齐、简洁干净就好，拒绝花里胡哨的色块和图标。\n\n\n\n#### 1.5 简历文件命名或格式不规范\n\n\n\n建议：简历文件的命名虽然没有绝对的规范，但是要 **仔细查看岗位描述** 是否有文件名规则的要求。\n\n\n\n注意！除公司特别要求之外，文件格式一定要用 PDF！！千万不要用 Word！！！因为使用 Word 可能会因为打开软件的版本不同而出现预期之外的排版错乱，这个影响是致命的。\n\n\n\n#### 1.6 简历中出现错别字\n\n\n\n建议：整个简历中千万不要有错别字！尤其是技术名词或者专业术语。否则会给人感觉非常不认真，竞争激烈时搞不好直接就挂了。\n\n\n\n所以写完简历后，一定要自己通读至少 3 遍，保证行文通顺、且无任何错别字！\n\n\n\n#### 1.7 简历没有明确的重点或求职方向\n\n\n\n建议：整个简历一定要有一个明确的、和求职岗位匹配的方向。\n\n\n\n我认识一些学的技术比较多的同学，他们可能又会 Python 又会 Java 又会前端，写到简历上的项目也是各方向的都有，然后又没有在简历的开头注明 “求职意向”，就导致面试官完全不知道他要找哪个方向的工作。\n\n\n\n并不是说会的技术、写简历上的技术太多了不好，而是要有一个侧重点。比如找 Java 岗位的工作就把 Java 项目放最上面，用更多的篇幅去介绍。也建议大家找工作前越早明确方向越好，不要到最后什么都只学了一点，反而平平无奇了。\n\n\n\n当然，如果你自己在多个方向学得都不错，可以准备多份不同的定制化简历，并根据不同的岗位、公司和岗位描述来调整优化简历（比如增加部分细节、调换内容的顺序等）。\n\n\n\n比如你前后端都会，投递后端开发岗位时，把后端技术放在前端技术上面去写，项目经历、实习经历等都要侧重于后端。\n\n\n\n#### 1.8 技术名词大小写错误\n\n\n\n建议：技术名词最好严格控制大小写，比如数据库技术写 “MySQL” 而不是 “mysql”，从微小的细节中体现你的专业性。\n\n\n\n#### 1.9 用词不专业或不凝练\n\n\n\n建议：简历上的每一个词汇，都能够反映出你的水平。\n\n\n\n很多同学的简历用词比较随意，比如 “我用 axios 库完成了对数据库的查询”。\n\n\n\n其实大家都心知肚明，axios 是一个前端请求库，可以和后台进行交互，实现对数据的查询和管理。\n\n\n\n但上面那个表达，语言不够清晰和凝练，还可能会给面试官一种感觉：你真的知道 axios 是什么？你真的和后端联调过么？\n\n\n\n所以，一定要保证简历上的每个词都要 **准确，不能产生歧义** 。另外，尽量减少口语化的内容，不说用 xx 技术做了 xx，而是用（基于） xx 技术实现了 xx。\n\n\n\n#### 1.10 内容重复\n\n\n\n建议：简历中（尤其是项目和工作描述中）尽量不要出现重复的内容，不仅占用了空间，还会让面试官感到疲惫。\n\n\n\n#### 1.11 简历内容过于简单\n\n\n\n建议：当你简历上没有什么可写的内容、又必须要尽快投递简历时，可以 **适当包装** 。\n\n\n\n注意，此处的包装不是指改变自己的学习、工作年限等（这种属于 “隐瞒和欺骗”，一般不建议这么做），而是指适当夸大。\n\n\n\n毕竟写简历的本质就是：**如何以一种吹牛皮的方式尽量表现出你的能力。**\n\n\n\n虽然写简历要真实，但不能太老实！尤其是对于没有工作经历、项目经历、荣誉奖项的同学，要学会适当包装、合理包装。\n\n\n\n比如尝试将你目前正在学的技术从 “了解” 改为 “熟悉”，或者把你还没来得及实现的项目功能先提前写上去等等。\n\n\n\n但是，不要过分包装，而且既然你提前把一些内容写到了简历上，就要加倍努力赶紧去真正学会 / 实现它。\n\n\n\n#### 1.12 简历内容很多，但没有突出重点\n\n\n\n建议：在写简历时，可以将部分内容片段进行加粗，或者多去写某部分的内容，来吸引面试官去提问。\n\n\n\n比如：\n\n\n\n1. 自己掌握的很好技术名词\n2. 自己项目中大量运用的技术\n3. 自己项目的优化成果数据\n4. 获得的名词较高、含金量较高的奖项\n5. 其他同学很少接触到的新技术或深入知识点\n\n\n\n#### 1.13 部分语句不通顺\n\n\n\n建议：你写在简历上的每一句话都有可能会暴露你的思维逻辑能力，所以必须保证语句通顺、逻辑合理。\n\n\n\n#### 1.14 简历空间没有合理利用\n\n\n\n建议：除非你实在写不满一页纸，否则简历上的所有内容都要做到 “惜字如金”。能只用一行写完的内容，就不要换第二行再加那么几个字。另外，简历上尽量不要出现空白，比如一行只写了半句话、或者只占用了半页纸等。\n\n\n\n实在不知道写什么，就去参考下别人的简历，并且自己再多学习一些技术、做一些项目。\n\n\n\n#### 1.15 简历各板块的顺序不合理\n\n\n\n建议：根据个人优势对各板块进行排序，把最有亮点的部分放上面。比如你的奖项比较多、但学历相对低了一些，就可以把奖项写在前面、学历放到最后去写。\n\n\n\n### 2、个人信息\n\n\n\n#### 2.1 个人信息占用的篇幅过多\n\n\n\n建议：一般个人信息只占用简历整体 5 ~ 10% 的篇幅即可。可以通过在一行内同时写多个信息来节约空间，并保证间距合理。\n\n\n\n#### 2.2 照片不清晰 / 不端正\n\n\n\n建议：照片要清晰端正，蓝底 / 白底 / 红底都可以，最好表情自然、面带微笑，尽量穿白衬衫或者正装，体现一个人的精神面貌。\n\n\n\n#### 2.3 写了固定的期望薪资范围\n\n\n\n建议：除非公司明确要求，否则不建议写期望薪资。原因如下：\n\n\n\n1. 很多公司的薪资还算公开透明，没必要写\n2. 可能你自己本身对某个行业的薪酬水平不了解，薪资写高了可能会错失求职机会\n3. 当你的表现或实际水平超出了你写的预期薪资范围时，会被人按照你的预期薪资来砍价，相当于把自己限制住了\n\n\n\n当然，如果你要应聘高级岗位、或者对自己很自信，那么可以写比较高的期望薪资，从而过滤一些公司、猎头的打扰。\n\n\n\n#### 2.4 缺少个人相关链接\n\n\n\n建议：因为简历的篇幅和内容有限，所以如果你的个人经历很丰富，推荐在简历上补充一些链接，比如个人网站、个人博客、个人作品集、代码仓库等，体现你的实践能力。\n\n\n\n### 3、教育背景\n\n\n\n#### 3.1 成绩排名一般\n\n\n\n建议：一般排名高于前 20% 的同学才建议在简历上写排名，否则没有优势。（尖子班除外）\n\n\n\n#### 3.2 主修课程浪费了空间\n\n\n\n建议：本身就是计算机相关专业（或者专业和求职岗位相匹配）的同学不用再占用空间去写自己的主修课程了，因为学校教的内容往往比较基础、而且面试官默认这个专业或者投递这个岗位的同学都应该会这些课，写上去也没有什么优势。\n\n\n\n但是建议非计算机相关专业（或者专业和求职岗位不匹配）的同学适当列举关键主修课程，优先列举和求职岗位相关的、取得分数较高的课。\n\n\n\n如果有得分较高的课程（比如 90 分以上），可以在课程名后用括号补充分数。\n\n\n\n#### 3.3 存在学历造假风险\n\n\n\n建议：除非迫不得已，否则不建议学历造假，因为大多数公司都是有背景调查的，哪怕通过造假顺利入职，也可能会被突然查出来并强制离职。\n\n\n\n### 4、技术栈\n\n\n\n#### 4.1 同一行列举了过多的技术名词\n\n\n\n建议：写你会的技术栈时，尽量不要用特别长的一句话、像报菜名似的列举过多技术名词。建议采用列表的形式，每一行单独写一个技术的多个子知识点或者一系列相关的技术，做到把每一块技术写得更具体、清晰。\n\n\n\n#### 4.2 XX 技术写得过于简略，没有充分利用空间\n\n\n\n建议：一般情况下，你掌握或熟悉的技术不要只写一个技术名词，而是建议利用好每一行的空间，多补充该技术中你掌握的知识点和技术细节，会让人觉得更真实、有说服力。\n\n\n\n当然，如果某个技术你只是了解或听说过，就把你知道的知识点写上去即可。\n\n\n\n#### 4.3 同一行列举了多个不相关的技术\n\n\n\n建议：从简历的技术栈部分中不仅可以看出你学过哪些技术、掌握哪些技术，还可以看出你对技术的分类和知识点的梳理能力。尽量每一行写清楚一个技术，或者把一系列相关的技术放在同一行（比如 SSM 框架）；而不要把前端、后端、算法等知识点混在同一行去写。\n\n\n\n#### 4.4 缺少你对 XX 技术的实践应用能力\n\n\n\n建议：技术栈部分光写自己会什么技术、了解哪些知识是不够的，因为大多数面试官重视的是你的实践能力，即你能不能使用该技术完成工作，而不是纸上谈兵。因此可以适当补充半句：“你能用这些技术做什么？”，从而体现你的实践能力。公司往往倾向于选择问题解决能力强、实践经验丰富的同学。\n\n\n\n#### 4.5 XX 内容过于基础，无法体现出你的能力\n\n\n\n建议：尽量避免去写默认所有人都会的内容，比如 Java 的几种数据结构、前端 HTML 的标签、面向对象编程等。\n\n\n\n#### 4.6 XX 内容写得过于宽泛和模糊，缺乏可信度\n\n\n\n建议：尽量不要写过于宽泛、模糊不清、无法证明的的内容，比如：\n\n\n\n-  熟悉面向对象编程 \n-  有一定后端基础 \n-  了解常见性能优化手段 \n-  有良好的开发规范 \n-  具备良好的编码能力 \n\n\n\n专业的面试官基本就默认当做你不了解、或者不具备这些能力。\n\n\n\n你应当把这些宽泛的知识具体化，比如：\n\n\n\n-  熟悉面向对象编程 => 了解哪些软件开发原则、熟悉哪些设计模式等？ \n-  有一定后端基础 => 你学过哪些后端知识？ \n-  了解常见性能优化手段 => 具体了解或实践过哪些性能优化手段？ \n-  有良好的开发规范 => 熟悉或使用过哪些开发规范、用过什么工具来规范团队开发？ \n-  具备良好的编码能力 => 会用哪些开发工具、熟悉哪些编程技巧？ \n\n\n\n写得更具体一些，才会更有说服力。\n\n\n\n#### 4.7 各技术点的顺序不当\n\n\n\n建议：和做短视频一样，我们要尽量把最吸引人的部分放在简历的最上面。所以建议优先把岗位描述中明确要求的、你学得最好的技术放在前面去写，和求职岗位关系没那么大的、仅是了解的知识点放到最后作为补充。\n\n\n\n#### 4.8 技术栈和其他同学过于相似，缺少区分度\n\n\n\n建议：哪怕大家都写同一个技术，你也可以写更多、更深入的知识点。\n\n\n\n建议多阅读借鉴他人简历的技术栈部分，查漏补缺。\n\n\n\n此外，平时除了学习主流技术外，最好能多去技术社区阅读一些技术文章，扩展自己的知识面。\n\n\n\n### 5、荣誉奖项\n\n\n\n#### 5.1 未重点突出高级别、高含金量的奖项\n\n\n\n建议：获得奖项的级别或含金量很高时，建议把奖项级别加粗来吸引面试官，比如 XX 竞赛全国 **一等奖** 。\n\n\n\n#### 5.2 奖项未排序\n\n\n\n建议：优先把认可度高的、参赛范围广的、获奖级别高的、和求职岗位更相关的奖项放上面，一些不知名的竞赛放到下面或者合并去写。\n\n\n\n### 6、工作经历（实习经历）\n\n\n\n#### 6.1 工作描述过于简单\n\n\n\n建议：写工作内容时，可以适当具体一些，比如补充你在这家公司用了什么技术、负责了什么样的项目、使用过什么方法和工具、解决过什么问题等，从而增加真实感。\n\n\n\n#### 6.2 工作内容和求职岗位关系不大\n\n\n\n建议：简历应当围绕求职岗位去写，重点去写求职岗位相关的经历。当然，如果有能证明你能力的其他工作经历，也可以简略说明，但不能占用过多篇幅。\n\n\n\n#### 6.3 缺少工作成果和个人价值的体现\n\n\n\n建议：尽量不要写自己在工作中收获了什么、学到了什么，而是多写自己做了什么、做出了什么成果，尤其是列举有明确数据的成果，比如 “写过 XX 篇文档、做过 X 场技术分享、给项目带来了多少的收入增长” 等，将更能体现自己的能力和价值。\n\n\n\n如果目前没有可写的成果，建议在之后的工作中多思考如何积累这些内容。\n\n\n\n#### 6.4 工作职责不明确\n\n\n\n建议：即使你在这家公司做了很多不同岗位的工作，也要有个重点突出的工作职责，而不是什么都写。\n\n\n\n#### 6.5 个人的工作内容不够突出\n\n\n\n建议：写工作内容的时候尽量突出自己的地位，在合适的情况下，尽量能把 “参与” 改成 “负责” 或 “主导” 某工作。\n\n\n\n#### 6.6 XX 工作写得过于宽泛和模糊，缺乏可信度\n\n\n\n建议：尽量让你的工作描述更有说服力，比如写 “与产品经理高效沟通”，不如改成去写：“你是怎么实现和他人的高效沟通？”，比如用了什么项目管理工具？或者跟前端协作时用了什么接口管理工具？\n\n\n\n### 7、项目经历\n\n\n\n#### 7.1 项目工作描述的写法存在不足\n\n\n\n建议：写项目的工作描述时，不要把所有内容混在一起，而是建议用列表的形式  **分点** 去写 ，每个工作 / 亮点独占一行，每一点 **尽量具体** 。写的越具体，往往越体现真实性。\n\n\n\n可用 STAR 分析法（场景、任务、行动、成果）来梳理自己的核心工作。\n\n\n\n提供 2 个标准句式，括号部分表示可选填：\n\n\n\n1. （在 xx 公司 xx 项目中，）在 xx 情况下，运用 xx 技术，解决了 xx（或者优化了 xx），达到了 xx 效果（或者带来 xx 收益等）。\n2. 为了解决 xx 问题，选用 xx 技术（或方法）实现了 xx，并使用 xx 技术（或方法）优化了 xx，实测提升了 xx 性能（或者降低了 xx 等）。\n\n\n\n举个例子：为适应产品特性、加快迭代速度，后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB ，实现了前后一体的 **集中式配置中心** ，提高了接近 **1 倍** 的开发效率。\n\n\n\n注意每个小点的长度不宜过长，要留给面试官提问的空间。\n\n\n\n#### 7.2 技术栈提到的技术没有在项目中运用\n\n\n\n建议：技术栈里提到的技术和知识点尽量多在项目经历中体现，否则容易给面试官一种 “只是学过或听说过，而不会运用” 的感觉。\n\n\n\n#### 7.3 项目技术或业务相似度过高\n\n\n\n建议：尽量不要写运用了太多重复技术栈、或者业务相似的项目，最好能够让各个项目形成互补。\n\n\n\n前端的话可以考虑一个 PC 端 + 一个移动端项目或者技术类项目（脚手架、组件库等）；后端可以考虑一个业务系统（比如管理系统、电商、社群、博客等）+ 一个技术类框架（比如 RPC、迷你 Spring、服务器等）。\n\n\n\n#### 7.4 项目过多\n\n\n\n建议：注意，写到简历上的项目不是越多越好！建议重点去写 2 - 3 个不同技术栈、不同业务场景的项目。\n\n\n\n一个功能完整的、描述清楚的、实际上线了的项目可能都比你写几个不上线的小 Demo 更有说服力。\n\n\n\n当然，如果你每个项目做的都很好，实在无法取舍的话就都写上吧~\n\n\n\n#### 7.5 项目介绍太长\n\n\n\n建议：注意每个项目里内容的比重，项目介绍的占比不要太多，一般 1 - 2 行足够了。\n\n\n\n记住，你不是在做推广！在简历中，面试官更关注的是 **你在项目中负责什么、做了什么、怎么通过技术和设计能力去解决问题的** 。至于项目本身的介绍，用一两句话直击核心就好，重点在于交代 **和你工作有关** 的内容，其余的可以在面试时展开介绍。\n\n\n\n#### 7.6 项目工作描述过于直白平淡\n\n\n\n建议：要想项目有亮点，需要 **深一度**。不能只写你完成了什么工作，而是要有一定的优化和扩展，让整句话读起来有起伏和递进。\n\n\n\n比如你可以在完成某功能的基础上进一步优化，或者改造现有的项目框架、推陈出新，或者提升系统各方面的性能（可用性、稳定性、用户体验、吞吐量、时延等）。\n\n\n\n建议大家多去了解你项目中用到的技术的同类技术，对这些技术的优缺点和适合的应用场景有个大致的印象。\n\n\n\n#### 7.7 项目没有提供可访问的线上地址\n\n\n\n建议：条件允许的话，强烈建议提供可在线访问的项目地址（域名尽量简短，好让面试官访问），从而体现你项目的真实性，将会是一个非常不错的加分项。\n\n\n\n因为绝大多数同学写项目经历的时候，不放已上线的项目地址。有的时候你写的点再多、吹得天花乱坠，都不如直接放一个可访问的项目地址来得实在，能够直接证明你真的做过这个项目、从而体现你的项目经验。对于前端同学来说这点更重要，直接给面试官看体验效果最实在。你做的网站用不用心，一看便知。\n\n\n\n#### 7.8 项目工作描述脱离了实际业务场景\n\n\n\n建议：写你在项目中的工作和技术运用时，最好能结合具体的业务去写，不要说写的所有内容都和你的项目本身关系不大、过于通用，即放到其他任何一个项目里都可以这么写。\n\n\n\n那样不仅缺少了真实性、也体现不出你的自主性以及对业务的思考。\n\n\n\n#### 7.9 各项目的工作描述存在重复\n\n\n\n建议：各项目的工作描述中尽量不要出现重复的内容，不仅浪费了空间，还会让面试官感到疲惫。\n\n\n\n#### 7.10 XX 技术不适合应用于当前项目的业务场景\n\n\n\n建议：每一个技术的运用都要切合实际的业务场景，不要为了用技术而用技术。\n\n\n\n在学习某个技术时必须要明确它的应用场景，而且在选用某个技术时，多思考你为什么用这项技术而不用同类的。比如你通过调研和对比发现你用的技术在当前业务场景下优势更明显，那么可以在项目的工作描述中补充这些对比以及你的思考，从而体现你的技术选型能力。\n\n\n\n#### 7.11 没有写具体的优化效果\n\n\n\n建议：只要提到 “优化” 这两个字，就一定要提供对比数据，即：优化后相对于优化前 xx 性能提升了多少？响应时长减少了多少？稳定性提升了多少等等，而不是脱离实际的测试去盲目做优化。\n\n\n\n#### 7.12 项目和其他同学过于相似，缺少区分度\n\n\n\n建议：其实绝大多数同学都是跟着网上的教程做项目，但同一个项目，也有高下之分。\n\n\n\n如果你做的是网上大众化的教程项目，建议给项目改个名、换个皮、自主加一些新功能、尝试做一些优化，来增加区分度。\n\n\n\n### 8、个人优势（自我评价）\n\n\n\n#### 8.1 自我评价没有说服力，属于正确的废话\n\n\n\n建议：自我评价板块不是必须要写的。如果要写，就 **必须让你的自我评价有信服力** ！\n\n\n\n不要只说自己哪里的能力强、怎么怎么厉害，而是需要一些事例、数据、证据来证明。\n\n\n\n举些例子：\n\n\n\n1. 我学习能力强，对新技术有强烈的好奇心 => 补充：曾通过官方文档、自主查阅资料自学了 XX、XX 新技术，并通过 RSS 持续关注该技术最新动态。\n2. 我乐于从事有挑战性的工作 => 补充：我曾经担任 XX 队长，在 XX 困难的条件下，解决了 XX 问题，取得了 XX 成果。\n3. 我喜欢分享知识、善于总结 => 补充：连续 XX 天发布个人博客，发布过 XX 个学习总结等等\n4. 我很帅 => 补充个人照片\n\n\n\n这样写自我评价，就不再是虚的了，而是真的能让面试官感受到你的这些优点。\n\n\n\n这里有个小技巧，可以根据目标公司的岗位要求去写自我评价，做到对号入座。\n\n\n\n![img](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1678440086802-f3ccf74d-c23c-435c-94cb-399e4072b4aa-20230424165651329.png)\n\n\n\n比如公司要求招有团队协作经验的，那就写：我善于团队合作，曾经组队参与 XX、XX 项目，统筹负责了 XX、XX，怎么提升团队工作效率之类的。\n\n\n\n这样从招聘者的角度来看，你是有用心准备过的，目的性明确，也是加分项。\n\n\n\n#### 8.2 自我评价板块篇幅占用较多\n\n\n\n建议：自我评价板块不是必须要写的，即使要写，也不要占用过多的篇幅。尽量通过技术栈、实践经历、荣誉奖项来更有力地突出你的优势。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 90,
        "thumbNum": 2,
        "favourNum": 4,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-24T09:40:05.000+00:00",
        "updateTime": "2023-05-06T15:26:39.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1310,
          "coin": 170,
          "followeeNum": 601,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-17T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-05-06T10:09:53.000+00:00"
        },
        "tags": [
          "文章",
          "简历",
          "经验分享",
          "求职"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "67",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "7"
  },
  "message": "ok"
}